// Code generated by Nexus Automation, DO NOT EDIT.

package generated

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Person interface {
	IsPerson()
}

type Address struct {
	Line1      string  `json:"line1"`
	Line2      *string `json:"line2,omitempty"`
	City       *string `json:"city,omitempty"`
	PostalCode string  `json:"postal_code"`
}

type AddressInput struct {
	Line1      string  `json:"line1"`
	Line2      *string `json:"line2,omitempty"`
	City       *string `json:"city,omitempty"`
	PostalCode string  `json:"postal_code"`
}

type Answer struct {
	Index  int    `json:"index"`
	Value  string `json:"value"`
	Reject bool   `json:"reject"`
}

type AnswerInput struct {
	Choice []*int  `json:"choice,omitempty"`
	Text   *string `json:"text,omitempty"`
}

type AnswerQuestionnaireInput struct {
	PatientID       string         `json:"patient_id"`
	QuestionnaireID string         `json:"questionnaire_id"`
	Answers         []*AnswerInput `json:"answers,omitempty"`
}

type Consultation struct {
	ID                     string               `json:"id"`
	QuestionnaireAnswersID string               `json:"questionnaire_answers_id"`
	PatientID              string               `json:"patient_id"`
	ProductID              string               `json:"product_id"`
	Assigned               *Prescriber          `json:"assigned,omitempty"`
	Events                 []*ConsultationEvent `json:"events,omitempty"`
	Status                 *ConsultationStatus  `json:"status,omitempty"`
}

type ConsultationEvent struct {
	Status    *ConsultationStatus `json:"status,omitempty"`
	Timestamp *time.Time          `json:"timestamp,omitempty"`
	Message   *string             `json:"message,omitempty"`
	Assigned  *Prescriber         `json:"assigned,omitempty"`
}

type CreateAnswer struct {
	Value  string `json:"value"`
	Reject *bool  `json:"reject,omitempty"`
}

type CreateConsultationInput struct {
	QuestionnaireAnswersID string `json:"questionnaire_answers_id"`
	ProductID              string `json:"product_id"`
}

type CreatePatientInput struct {
	Name    *NameInput    `json:"name,omitempty"`
	Phone   *string       `json:"phone,omitempty"`
	Email   *string       `json:"email,omitempty"`
	Address *AddressInput `json:"address,omitempty"`
}

type CreatePaymentInput struct {
	ConsultationID  string             `json:"consultation_id"`
	Integration     PaymentIntegration `json:"integration"`
	Shipping        ShippingService    `json:"shipping"`
	PaymentMethodID *string            `json:"payment_method_id,omitempty"`
}

type CreateQuestionnaireInput struct {
	Title     *string          `json:"title,omitempty"`
	Questions []*QuestionInput `json:"questions,omitempty"`
}

type Dosage struct {
	Quantity *float64    `json:"quantity,omitempty"`
	Unit     *DosageUnit `json:"unit,omitempty"`
}

type Medication struct {
	Name *string `json:"name,omitempty"`
}

type Name struct {
	Title      *string `json:"title,omitempty"`
	GivenName  string  `json:"given_name"`
	FamilyName string  `json:"family_name"`
}

type NameInput struct {
	Title      *string `json:"title,omitempty"`
	GivenName  string  `json:"given_name"`
	FamilyName string  `json:"family_name"`
}

type Patient struct {
	ID      string      `json:"id"`
	Name    *Name       `json:"name,omitempty"`
	Phone   *string     `json:"phone,omitempty"`
	Email   *string     `json:"email,omitempty"`
	Address *Address    `json:"address,omitempty"`
	Stripe  *StripeInfo `json:"stripe,omitempty"`
}

func (Patient) IsPerson() {}

type Payment struct {
	Stripe   *Stripe   `json:"stripe,omitempty"`
	Amount   *int      `json:"amount,omitempty"`
	Currency *string   `json:"currency,omitempty"`
	Shipping *Shipping `json:"shipping,omitempty"`
}

type Prescriber struct {
	ID   string `json:"id"`
	Name *Name  `json:"name,omitempty"`
}

func (Prescriber) IsPerson() {}

type Product struct {
	ID     string  `json:"id"`
	Rx     *Rx     `json:"rx,omitempty"`
	Price  int     `json:"price"`
	Weight *Weight `json:"weight,omitempty"`
}

type Products struct {
	Items     []*Product `json:"items,omitempty"`
	NextToken *string    `json:"nextToken,omitempty"`
}

type Question struct {
	Index   int          `json:"index"`
	Text    string       `json:"text"`
	Type    QuestionType `json:"type"`
	Answers []*Answer    `json:"answers,omitempty"`
}

type QuestionInput struct {
	Type    QuestionType    `json:"type"`
	Text    string          `json:"text"`
	Answers []*CreateAnswer `json:"answers,omitempty"`
}

type Questionnaire struct {
	ID        string      `json:"id"`
	Title     *string     `json:"title,omitempty"`
	Questions []*Question `json:"questions,omitempty"`
}

type QuestionnaireAnswer struct {
	Question *Question `json:"question,omitempty"`
	Value    []string  `json:"value,omitempty"`
}

type QuestionnaireAnswers struct {
	ID              string                 `json:"id"`
	PatientID       string                 `json:"patient_id"`
	QuestionnaireID string                 `json:"questionnaire_id"`
	Answers         []*QuestionnaireAnswer `json:"answers,omitempty"`
}

type Rx struct {
	Medication *Medication `json:"medication,omitempty"`
	Dosage     *Dosage     `json:"dosage,omitempty"`
	Usage      *Usage      `json:"usage,omitempty"`
	Quantity   int         `json:"quantity"`
}

type Shipping struct {
	Service *ShippingService `json:"service,omitempty"`
	Courier *Courier         `json:"courier,omitempty"`
}

type Stripe struct {
	IntentID     *string `json:"intent_id,omitempty"`
	ClientSecret *string `json:"client_secret,omitempty"`
}

type StripeInfo struct {
	CustomerID *string `json:"customer_id,omitempty"`
}

type UpdatePatientInput struct {
	ID      string        `json:"id"`
	Name    *NameInput    `json:"name,omitempty"`
	Phone   *string       `json:"phone,omitempty"`
	Email   *string       `json:"email,omitempty"`
	Address *AddressInput `json:"address,omitempty"`
}

type Usage struct {
	Text *string `json:"text,omitempty"`
}

type Weight struct {
	Quantity *float64    `json:"quantity,omitempty"`
	Unit     *WeightUnit `json:"unit,omitempty"`
}

type ConsultationStatus string

const (
	ConsultationStatusRequested  ConsultationStatus = "requested"
	ConsultationStatusPending    ConsultationStatus = "pending"
	ConsultationStatusCreated    ConsultationStatus = "created"
	ConsultationStatusAssigned   ConsultationStatus = "assigned"
	ConsultationStatusUnassigned ConsultationStatus = "unassigned"
	ConsultationStatusAccepted   ConsultationStatus = "accepted"
	ConsultationStatusRejected   ConsultationStatus = "rejected"
	ConsultationStatusCompleted  ConsultationStatus = "completed"
	ConsultationStatusExpired    ConsultationStatus = "expired"
	ConsultationStatusCancelled  ConsultationStatus = "cancelled"
)

var AllConsultationStatus = []ConsultationStatus{
	ConsultationStatusRequested,
	ConsultationStatusPending,
	ConsultationStatusCreated,
	ConsultationStatusAssigned,
	ConsultationStatusUnassigned,
	ConsultationStatusAccepted,
	ConsultationStatusRejected,
	ConsultationStatusCompleted,
	ConsultationStatusExpired,
	ConsultationStatusCancelled,
}

func (e ConsultationStatus) IsValid() bool {
	switch e {
	case ConsultationStatusRequested, ConsultationStatusPending, ConsultationStatusCreated, ConsultationStatusAssigned, ConsultationStatusUnassigned, ConsultationStatusAccepted, ConsultationStatusRejected, ConsultationStatusCompleted, ConsultationStatusExpired, ConsultationStatusCancelled:
		return true
	}
	return false
}

func (e ConsultationStatus) String() string {
	return string(e)
}

func (e *ConsultationStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConsultationStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConsultationStatus", str)
	}
	return nil
}

func (e ConsultationStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Courier string

const (
	CourierHermes    Courier = "hermes"
	CourierRoyalMail Courier = "royal_mail"
)

var AllCourier = []Courier{
	CourierHermes,
	CourierRoyalMail,
}

func (e Courier) IsValid() bool {
	switch e {
	case CourierHermes, CourierRoyalMail:
		return true
	}
	return false
}

func (e Courier) String() string {
	return string(e)
}

func (e *Courier) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Courier(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Courier", str)
	}
	return nil
}

func (e Courier) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DosageUnit string

const (
	DosageUnitMg  DosageUnit = "mg"
	DosageUnitMcg DosageUnit = "mcg"
	DosageUnitMl  DosageUnit = "ml"
	DosageUnitIu  DosageUnit = "iu"
)

var AllDosageUnit = []DosageUnit{
	DosageUnitMg,
	DosageUnitMcg,
	DosageUnitMl,
	DosageUnitIu,
}

func (e DosageUnit) IsValid() bool {
	switch e {
	case DosageUnitMg, DosageUnitMcg, DosageUnitMl, DosageUnitIu:
		return true
	}
	return false
}

func (e DosageUnit) String() string {
	return string(e)
}

func (e *DosageUnit) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DosageUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DosageUnit", str)
	}
	return nil
}

func (e DosageUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PaymentIntegration string

const (
	PaymentIntegrationRedirectURL PaymentIntegration = "redirect_url"
	PaymentIntegrationSelfHost    PaymentIntegration = "self_host"
	PaymentIntegrationSendLink    PaymentIntegration = "send_link"
)

var AllPaymentIntegration = []PaymentIntegration{
	PaymentIntegrationRedirectURL,
	PaymentIntegrationSelfHost,
	PaymentIntegrationSendLink,
}

func (e PaymentIntegration) IsValid() bool {
	switch e {
	case PaymentIntegrationRedirectURL, PaymentIntegrationSelfHost, PaymentIntegrationSendLink:
		return true
	}
	return false
}

func (e PaymentIntegration) String() string {
	return string(e)
}

func (e *PaymentIntegration) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentIntegration(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentIntegration", str)
	}
	return nil
}

func (e PaymentIntegration) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type QuestionType string

const (
	QuestionTypeFreeText   QuestionType = "free_text"
	QuestionTypeOneOfMany  QuestionType = "one_of_many"
	QuestionTypeManyOfMany QuestionType = "many_of_many"
)

var AllQuestionType = []QuestionType{
	QuestionTypeFreeText,
	QuestionTypeOneOfMany,
	QuestionTypeManyOfMany,
}

func (e QuestionType) IsValid() bool {
	switch e {
	case QuestionTypeFreeText, QuestionTypeOneOfMany, QuestionTypeManyOfMany:
		return true
	}
	return false
}

func (e QuestionType) String() string {
	return string(e)
}

func (e *QuestionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = QuestionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid QuestionType", str)
	}
	return nil
}

func (e QuestionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ShippingService string

const (
	ShippingServiceStandard ShippingService = "standard"
	ShippingServicePremium  ShippingService = "premium"
)

var AllShippingService = []ShippingService{
	ShippingServiceStandard,
	ShippingServicePremium,
}

func (e ShippingService) IsValid() bool {
	switch e {
	case ShippingServiceStandard, ShippingServicePremium:
		return true
	}
	return false
}

func (e ShippingService) String() string {
	return string(e)
}

func (e *ShippingService) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShippingService(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShippingService", str)
	}
	return nil
}

func (e ShippingService) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WeightUnit string

const (
	WeightUnitGrams     WeightUnit = "grams"
	WeightUnitKilograms WeightUnit = "kilograms"
)

var AllWeightUnit = []WeightUnit{
	WeightUnitGrams,
	WeightUnitKilograms,
}

func (e WeightUnit) IsValid() bool {
	switch e {
	case WeightUnitGrams, WeightUnitKilograms:
		return true
	}
	return false
}

func (e WeightUnit) String() string {
	return string(e)
}

func (e *WeightUnit) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WeightUnit(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WeightUnit", str)
	}
	return nil
}

func (e WeightUnit) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
